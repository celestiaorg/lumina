use std::path::{Path, PathBuf};

use anyhow::{Context, Result};

use crate::domain::types::{ReleaseContext, ReleaseMode};
use crate::infra::git_refs::remote_origin_url;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PullRequestInfo {
    pub number: u64,
    pub url: String,
}

#[derive(Debug, Clone)]
pub struct GitHubCliOps {
    workspace_root: PathBuf,
}

impl GitHubCliOps {
    pub fn new(workspace_root: PathBuf) -> Self {
        Self { workspace_root }
    }

    pub async fn has_external_contributors_on_open_release_pr(
        &self,
        ctx: &ReleaseContext,
        branch_name: &str,
    ) -> Result<bool> {
        let Some(client) = self.git_client(ctx)? else {
            return Ok(false);
        };
        let Some(pr) = self.find_open_release_pr(&client, branch_name).await? else {
            return Ok(false);
        };

        let commits = client
            .pr_commits(pr.number)
            .await
            .with_context(|| format!("failed to load commits for PR #{}", pr.number))?;

        // Skip PR author commit and bots, then deduplicate.
        let mut contributors = commits
            .into_iter()
            .skip(1)
            .filter_map(|commit| commit.author.map(|author| author.login))
            .filter(|login| !login.ends_with("[bot]"))
            .collect::<Vec<_>>();
        contributors.sort();
        contributors.dedup();

        Ok(!contributors.is_empty())
    }

    pub async fn close_open_release_pr(
        &self,
        ctx: &ReleaseContext,
        branch_name: &str,
    ) -> Result<Option<PullRequestInfo>> {
        if ctx.skip_pr {
            return Ok(None);
        }
        let Some(client) = self.git_client(ctx)? else {
            return Ok(None);
        };
        let Some(pr) = self.find_open_release_pr(&client, branch_name).await? else {
            return Ok(None);
        };

        client
            .close_pr(pr.number)
            .await
            .with_context(|| format!("failed to close PR #{}", pr.number))?;

        Ok(Some(PullRequestInfo {
            number: pr.number,
            url: pr.html_url.to_string(),
        }))
    }

    pub async fn ensure_release_pr(
        &self,
        ctx: &ReleaseContext,
        branch_name: &str,
    ) -> Result<Option<PullRequestInfo>> {
        if ctx.skip_pr {
            return Ok(None);
        }
        let Some(client) = self.git_client(ctx)? else {
            return Ok(None);
        };

        if let Some(existing) = self.find_open_release_pr(&client, branch_name).await? {
            return Ok(Some(PullRequestInfo {
                number: existing.number,
                url: existing.html_url.to_string(),
            }));
        }

        let (title, body) = match ctx.mode {
            ReleaseMode::Rc => (
                "chore: prepare rc release",
                "Prepare rc release updates generated by xtask.",
            ),
            ReleaseMode::Final => (
                "chore: prepare final release",
                "Prepare final release updates generated by xtask.",
            ),
        };

        let pr = release_plz_core::Pr {
            base_branch: ctx.default_branch.clone(),
            branch: branch_name.to_string(),
            title: title.to_string(),
            body: body.to_string(),
            draft: false,
            labels: vec![],
        };
        let opened = client
            .open_pr(&pr)
            .await
            .context("failed to open release PR")?;

        Ok(Some(PullRequestInfo {
            number: opened.number,
            url: opened.html_url.to_string(),
        }))
    }

    async fn find_open_release_pr(
        &self,
        client: &release_plz_core::GitClient,
        branch_name: &str,
    ) -> Result<Option<release_plz_core::GitPr>> {
        let prs = client
            .opened_prs("")
            .await
            .context("failed to list opened PRs")?;
        Ok(prs.into_iter().find(|pr| pr.branch() == branch_name))
    }

    fn git_client(&self, ctx: &ReleaseContext) -> Result<Option<release_plz_core::GitClient>> {
        let token = ctx
            .auth
            .release_plz_token
            .clone()
            .or_else(|| ctx.auth.github_token.clone());
        let Some(token) = token else {
            return Ok(None);
        };

        let Some(repo_url) = self.remote_repo_url()? else {
            return Ok(None);
        };

        let client = release_plz_core::GitClient::new(release_plz_core::GitForge::Github(
            release_plz_core::GitHub::new(repo_url.owner, repo_url.name, token.into()),
        ))
        .context("failed to build GitHub client")?;
        Ok(Some(client))
    }

    fn remote_repo_url(&self) -> Result<Option<release_plz_core::RepoUrl>> {
        remote_repo_url(&self.workspace_root)
    }
}

fn remote_repo_url(workspace_root: &Path) -> Result<Option<release_plz_core::RepoUrl>> {
    let Some(remote) = remote_origin_url(workspace_root)? else {
        return Ok(None);
    };

    let repo_url = release_plz_core::RepoUrl::new(&remote)
        .with_context(|| format!("failed to parse repository URL from `{remote}`"))?;
    Ok(Some(repo_url))
}
