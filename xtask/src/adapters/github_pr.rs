use std::path::PathBuf;

use anyhow::{Context, Result};
use tracing::info;

use crate::adapters::git_refs::parse_remote_repo_url;
use crate::domain::model::{RELEASE_PR_TITLE_FINAL, RELEASE_PR_TITLE_PREFIX, RELEASE_PR_TITLE_RC};
use crate::domain::types::{AuthContext, PullRequestInfo, ReleaseMode};

#[derive(Debug, Clone)]
pub struct GitHubPrClient {
    workspace_root: PathBuf,
}

impl GitHubPrClient {
    pub fn new(workspace_root: PathBuf) -> Self {
        Self { workspace_root }
    }

    async fn find_open_release_pr(
        &self,
        client: &release_plz_core::GitClient,
        branch_name: &str,
    ) -> Result<Option<release_plz_core::GitPr>> {
        let prs = client
            .opened_prs("")
            .await
            .context("failed to list opened PRs")?;
        Ok(prs.into_iter().find(|pr| pr.branch() == branch_name))
    }

    async fn open_release_prs(
        &self,
        client: &release_plz_core::GitClient,
    ) -> Result<Vec<release_plz_core::GitPr>> {
        let prs = client
            .opened_prs("")
            .await
            .context("failed to list opened PRs")?;
        Ok(prs.into_iter().filter(is_release_pr_candidate).collect())
    }

    fn git_client(&self, auth: &AuthContext) -> Result<Option<release_plz_core::GitClient>> {
        let token = auth
            .release_plz_token
            .clone()
            .or_else(|| auth.github_token.clone());
        let Some(token) = token else {
            return Ok(None);
        };

        let Some(repo_url) = self.remote_repo_url()? else {
            return Ok(None);
        };

        let client = release_plz_core::GitClient::new(release_plz_core::GitForge::Github(
            release_plz_core::GitHub::new(repo_url.owner, repo_url.name, token.into()),
        ))
        .context("failed to build GitHub client")?;
        Ok(Some(client))
    }

    fn remote_repo_url(&self) -> Result<Option<release_plz_core::RepoUrl>> {
        parse_remote_repo_url(&self.workspace_root)
    }

    pub async fn close_stale_open_release_prs(
        &self,
        auth: &AuthContext,
        skip_pr: bool,
        keep_branch: Option<&str>,
    ) -> Result<Vec<PullRequestInfo>> {
        if skip_pr {
            return Ok(vec![]);
        }
        let Some(client) = self.git_client(auth)? else {
            return Ok(vec![]);
        };

        let keep_branch = keep_branch.map(str::to_string);
        let release_prs = self.open_release_prs(&client).await?;
        let stale_prs = release_prs
            .into_iter()
            .filter(|pr| keep_branch.as_deref() != Some(pr.branch()))
            .collect::<Vec<_>>();

        let mut closed = Vec::new();
        for pr in stale_prs {
            client
                .close_pr(pr.number)
                .await
                .with_context(|| format!("failed to close stale release PR #{}", pr.number))?;
            closed.push(PullRequestInfo {
                number: pr.number,
                url: pr.html_url.to_string(),
            });
        }
        info!(
            keep_branch=?keep_branch,
            closed_prs=closed.len(),
            "github_pr: stale release PR cleanup completed"
        );

        Ok(closed)
    }

    pub async fn ensure_release_pr(
        &self,
        mode: ReleaseMode,
        default_branch: &str,
        auth: &AuthContext,
        skip_pr: bool,
        branch_name: &str,
    ) -> Result<Option<PullRequestInfo>> {
        if skip_pr {
            return Ok(None);
        }
        let Some(client) = self.git_client(auth)? else {
            return Ok(None);
        };

        if let Some(existing) = self.find_open_release_pr(&client, branch_name).await? {
            info!(branch=%branch_name, pr_number=existing.number, "github_pr: reusing existing open PR");
            return Ok(Some(PullRequestInfo {
                number: existing.number,
                url: existing.html_url.to_string(),
            }));
        }

        let (title, body) = match mode {
            ReleaseMode::Rc => (
                RELEASE_PR_TITLE_RC,
                "Prepare rc release updates generated by xtask.",
            ),
            ReleaseMode::Final => (
                RELEASE_PR_TITLE_FINAL,
                "Prepare final release updates generated by xtask.",
            ),
        };

        let pr = release_plz_core::Pr {
            base_branch: default_branch.to_string(),
            branch: branch_name.to_string(),
            title: title.to_string(),
            body: body.to_string(),
            draft: false,
            labels: vec![],
        };
        let opened = client
            .open_pr(&pr)
            .await
            .context("failed to open release PR")?;
        info!(
            branch=%branch_name,
            pr_number=opened.number,
            pr_url=%opened.html_url,
            "github_pr: opened release PR"
        );

        Ok(Some(PullRequestInfo {
            number: opened.number,
            url: opened.html_url.to_string(),
        }))
    }
}

fn is_release_pr_candidate(pr: &release_plz_core::GitPr) -> bool {
    let title = pr.title.to_ascii_lowercase();
    title.contains(RELEASE_PR_TITLE_PREFIX)
}
